<!---   THIS FILE IS AUTOMATICALLY GENERATED, DO NOT CHANGE IT BY HAND   --->

 <p align="center">
 <img src="cast.svg" alt="A logo portraying a magic wand" /><br />
 Single header type conversions library
 </p>

 cast.h
 ======


 Motivation
 ----------

 Properly converting between types is a tedious task.

 - Some conversions result in a loss of data, implementation defined behavior
   or even undefined behavior (damn nasal deamons).
 - Converting between types using casting operators `(type)`,
   does not convey clear the intention of the programmer. Is the cast done,
   because the value is guaranteed to fit destination type? Is it done
   because truncating the data is expected?
 - Casting operators silence compiler warnings about conversions. If there is
   a conversion `(uint8_t)var`, where `var` is `uint32_t`, and in future the code
   is changed, so that type of `var` becomes `float`, most likely the code
   where conversion occurs should be reviewed again, but it can be overlooked,
   because an expression which uses a casting operator usually does not produce
   warnings.
 - Always manually writing conditions to check if value fits a given range is
   error prone.

 This library of helper function was created to adress these problems.

 And let's be honest. The world just needs an another C single header library.


 Installation
 ------------

 `cast.h` is a
[STB-style](https://github.com/nothings/stb/blob/master/docs/stb_howto.txt)
 single header library, because single header libraries are easy to integrate.

 Just drop in `cast.h` directly into your project and create a `.c` file with
 the following contents:

 ```c
 // cast.c
 #define CAST_IMPLEMENTATION
 #include "cast.h"
 ```

 Once you've done that, you can include `cast.h` in other translation units
and start using conversion functions.

 ```c
 // other translation unit

 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <inttypes.h>

 #include "cast.h"

 int main(int argc, char **argv)
 {
 	uint8_t count = 0;
	// non-panicking variant
 	if (try_u8_from_int(&count, argc)) {
 		printf("Too many arguments\n");
 		return EXIT_FAILURE;
 	}
 	printf("count %u\n", count);

 	if (count < 30) {
 		// this would have invoked panic handler is count was greater that INT8_MAX
 		int8_t x = i8_from_u8(count);
 		foo(x);
 	}

 	return 0;
 }
 ```

 Usage
 -----

 The library provides two kinds of functions:

 - Error returning functions - these functions are in form of
   `try_{T'}_from_{U'}(T* dst, U src)` and they return an error on failure.
   These function can be used in cases where it is not guaranteed that
   value will fit.

 - Constraint handler invoking functions - these functions are in form of
   `{T'}_from_{U'}(U src)` and they invoke constaint handler on failure. The
   default behavior of constraing handler is to call `exit(1)` and crash the
   application. This function can be used in cases where conversion is
expected to succeed and failure is a programming error or security error,
which shall lead to immediate program termination.

 ### Error returning functions

 To convert from `U` type to `T` type use:

 ```c
 int try_{T'}_from_{U'}(T *dst, U src);
 ```

 Example:

 ```c
 void foo(int x, short x)
 {
 	uint32_t dst_u32 = 0U;
 	int err = try_u32_from_int(&dst_u32, x);
 	if (err) {
 		// Handle error
 		return;
 	}
 	printf("%"PRNu32"\n", dst_u32);

 	size_t count = 0U;
 	int err = try_size_from_short(&count, x);
 	if (err) {
 		// Handle error
 		return;
 	}
 	printf("%zu\n", count);
 }
 ```

 ### Constraint handler invoking functions

 To convert from `U` type to `T`, without error handling:

 ```c
 T {T'}_from_{U'}(U src);
 ```

 Example:

 ```c
 void print_numbers(int *numbers, int count)
 {
 	if (!numbers)
		return;
      // Program will crash if count is < 0
 	for (size_t i = 0; i < size_from_int(count); ++i) {
		printf("%d", numbers[i]);
 	}
 }
 ```

 ### Short names

 The `T'` and `U'` as opposed to (`T` and `U`) are short version of type
 names. Here is a full list:

 - T: `uint8_t`, T': `u8`
 - T: `uint16_t`, T': `u16`
 - T: `uint32_t`, T': `u32`
 - T: `uint64_t`, T': `u64`
 - T: `int8_t`, T': `i8`
 - T: `int16_t`, T': `i16`
 - T: `int32_t`, T': `i32`
 - T: `int64_t`, T': `i64`
 - T: `short`, T': `short`
 - T: `int`, T': `int`
 - T: `long`, T': `long`
 - T: `long long`, T': `llong`
 - T: `unsigned short`, T': `ushort`
 - T: `unsigned int`, T': `uint`
 - T: `unsigned long`, T': `ulong`
 - T: `unsigned long long`, T': `ullong`
 - T: `bool`, T': `bool`
 - T: `float`, T': `float`
 - T: `double`, T': `double`
 - T: `size_t`, T': `size`
 - T: `ptrdiff_t`, T': `ptrdiff`
 - T: `uintptr_t`, T': `uptr`
